//go:build !nocli

package main

import (
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/asaskevich/govalidator"
	"github.com/e1732a364fed/v2ray_simple/configAdapter"
	"github.com/e1732a364fed/v2ray_simple/proxy"
	"github.com/e1732a364fed/v2ray_simple/utils"
	"github.com/manifoldco/promptui"
)

func interactively_exportVsConf() {
	vc := mainM.DumpVSConf()

	bs, e := utils.GetPurgedTomlBytes(vc)
	if e != nil {
		utils.PrintStr("转换格式错误\n")
		utils.PrintStr(e.Error())
		utils.PrintStr("\n")
		return
	}

	utils.PrintStr("请输入生成配置文件的名称(不含.toml后缀)\n")

	promptDomain := promptui.Prompt{
		Label: "文件名",
	}

	result, err := promptDomain.Run()
	if err != nil {
		fmt.Println("Prompt failed ", err, result)
		return
	}

	fmt.Printf("你输入了 %s\n", result)

	e = os.WriteFile(result+".toml", bs, 0666)

	if e != nil {
		utils.PrintStr("写入文件错误\n")
		utils.PrintStr(e.Error())
		utils.PrintStr("\n")
		return
	}

	utils.PrintStr("导出成功!\n")
}

func interactively_generate_share(conf *proxy.StandardConf) {

	all := []*CliCmd{
		{
			Name: "vs标准url (可用于 极简/命令行模式, #163)",
			f: func() {
				fmt.Println("Dials:")

				for _, v := range conf.Dial {
					url := proxy.ToStandardUrl(&v.CommonConf, v, nil)
					fmt.Println(url)
				}

				fmt.Println("\nListens:")

				for _, v := range conf.Listen {
					url := proxy.ToStandardUrl(&v.CommonConf, nil, v)
					fmt.Println(url)
				}
			},
		},
		{
			Name: "vs标准toml",
			f: func() {
				fmt.Println("#vs_auto_generated:")
				gstr, e := utils.GetPurgedTomlStr(conf)
				if e != nil {
					fmt.Println(e.Error())

				} else {
					fmt.Println(gstr)

				}

			},
		},
		{
			Name: "v2rayN分享链接 (vmess://base64)",
			f: func() {
				for _, v := range conf.Dial {
					url := configAdapter.ToV2rayN(v)
					fmt.Println(url)
				}
			},
		},
		{
			Name: "xray分享链接标准提案 (#716)",
			f: func() {
				for _, v := range conf.Dial {
					url := configAdapter.ToXray(v)
					fmt.Println(url)
				}
			},
		},
		{
			Name: "shadowsocks uri (SIP002)",
			f: func() {
				for _, v := range conf.Dial {
					url := configAdapter.ToSS(&v.CommonConf, nil, false, 4)
					fmt.Println(url)
				}
			},
		},

		{
			Name: "Quantumult X (圈叉的配置的 [server_local] 部分)",
			f: func() {
				for _, v := range conf.Dial {
					url := configAdapter.ToQX(v)
					fmt.Println(url)
				}
			},
		},
		{
			Name: "Clash (yaml配置中 proxies 部分)",
			f: func() {
				for _, v := range conf.Dial {
					url := configAdapter.ToClash(v)
					fmt.Println(url)
				}
			},
		},
	}

	select0 := promptui.Select{
		Label: "请选择你想导出的分享格式 (注意, 某些分享格式只支持特定协议或特定配置)",
		Items: all,
	}
	i1, result, err := select0.Run()

	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return
	}

	fmt.Printf("你选择了 %s\n", result)

	flist := flist(all)
	flist[i1]()
}

func interactively_generateConf(confClient, confServer *proxy.StandardConf) {

	select2 := promptui.Select{
		Label: "请选择你客户端想监听的协议",
		Items: []string{
			"socks5",
			"http",
			"socks5http",
		},
	}
	i2, result, err := select2.Run()

	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return
	}

	fmt.Printf("你选择了 %s\n", result)

	if i2 < 3 {
		confClient.Listen = append(confClient.Listen, &proxy.ListenConf{})
	} else {
		utils.PrintStr("Prompt failed, werid input")
		return
	}

	clientlisten := confClient.Listen[0]
	clientlisten.Protocol = result
	clientlisten.Tag = "my_" + result

	var theInt int64

	var canLowPort bool
	validatePort := func(input string) error {
		theInt, err = strconv.ParseInt(input, 10, 64)
		if err != nil {
			return utils.ErrInvalidNumber
		}
		if !canLowPort {
			if theInt <= 1024 {
				return utils.ErrInvalidNumber
			}
		}
		if theInt > 65535 {
			return utils.ErrInvalidNumber
		}
		return nil
	}

	utils.PrintStr("请输入你客户端想监听的端口\n")

	promptPort := promptui.Prompt{
		Label:    "Port Number",
		Validate: validatePort,
	}

	result, err = promptPort.Run()

	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return
	}

	fmt.Printf("你输入了 %d\n", theInt)

	clientlisten.Port = int(theInt)
	clientlisten.IP = "127.0.0.1"

	select3 := promptui.Select{
		Label: "请选择你客户端想拨号的协议(与服务端监听协议相同)",
		Items: []string{
			"vless",
			"vmess",
			"trojan",
			"shadowsocks",
		},
	}
	i3, result, err := select3.Run()

	if err != nil {
		fmt.Println("Prompt failed ", err, i3)
		return
	}

	fmt.Printf("你选择了 %s\n", result)
	theProtocol := result

	confClient.Dial = append(confClient.Dial, &proxy.DialConf{})
	clientDial := confClient.Dial[0]

	utils.PrintStr("请输入你服务端想监听的端口\n")
	canLowPort = true

	result, err = promptPort.Run()

	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return
	}

	fmt.Printf("你输入了 %d\n", theInt)

	clientDial.Port = int(theInt)
	clientDial.Protocol = theProtocol
	clientDial.TLS = true
	clientDial.Tag = "my_proxy"

	select4 := promptui.Select{
		Label: "请选择你客户端拨号想使用的高级层(与服务端监听的高级层相同)",
		Items: []string{
			"无",
			"ws",
			"grpc",
			"quic",
		},
	}
	i4, result, err := select4.Run()

	if err != nil {
		fmt.Println("Prompt failed ", err, i4)
		return
	}

	switch i4 {
	case 0:
	default:
		clientDial.AdvancedLayer = result
		switch i4 {
		case 1, 2:
			clientlisten.Tag += "_" + result
			promptPath := promptui.Prompt{
				Label: "Path",
				Validate: func(s string) error {
					if result == "ws" && !strings.HasPrefix(s, "/") {
						return errors.New("ws path must start with /")
					}
					return nil
				},
			}

			result, err = promptPath.Run()
			if err != nil {
				fmt.Println("Prompt failed ", err, result)
				return
			}

			fmt.Printf("你输入了 %s\n", result)

			clientDial.Path = result

		}
	}

	utils.PrintStr("请输入你服务端的ip\n")

	promptIP := promptui.Prompt{
		Label:    "IP",
		Validate: utils.WrapFuncForPromptUI(govalidator.IsIP),
	}

	result, err = promptIP.Run()
	if err != nil {
		fmt.Println("Prompt failed ", err, result)
		return
	}

	fmt.Printf("你输入了 %s\n", result)

	clientDial.IP = result

	utils.PrintStr("请输入你服务端的域名\n")

	promptDomain := promptui.Prompt{
		Label: "域名",
	}

	result, err = promptDomain.Run()
	if err != nil {
		fmt.Println("Prompt failed ", err, result)
		return
	}

	fmt.Printf("你输入了 %s\n", result)

	clientDial.Host = result

	select5 := promptui.Select{
		Label: "请选择uuid生成方式",
		Items: []string{
			"随机",
			"手动输入(要保证你输入的是格式正确的uuid)",
		},
	}
	i5, result, err := select5.Run()

	if err != nil {
		fmt.Println("Prompt failed ", err, i5)
		return
	}
	if i5 == 0 {
		uuid := utils.GenerateUUIDStr()
		clientDial.UUID = uuid
		fmt.Println("随机生成的uuid为", uuid)
	} else {
		promptUUID := promptui.Prompt{
			Label:    "uuid",
			Validate: utils.WrapFuncForPromptUI(govalidator.IsUUID),
		}

		result, err = promptUUID.Run()
		if err != nil {
			fmt.Println("Prompt failed ", err, result)
			return
		}

		fmt.Printf("你输入了 %s\n", result)

		clientDial.UUID = result
	}

	var serverListenStruct proxy.ListenConf
	serverListenStruct.CommonConf = clientDial.CommonConf
	serverListenStruct.IP = "0.0.0.0"

	confServer.Listen = append(confServer.Listen, &serverListenStruct)

	confServer.Dial = append(confServer.Dial, &proxy.DialConf{
		CommonConf: proxy.CommonConf{
			Protocol: "direct",
		},
	})

	serverListen := confServer.Listen[0]

	select6 := promptui.Select{
		Label: "请配置服务端tls证书路径",
		Items: []string{
			"默认(cert.pem和cert.key),此时将自动开启 insecure",
			"手动输入(要保证你输入的是正确的文件路径)",
		},
	}
	i6, result, err := select6.Run()

	if err != nil {
		fmt.Println("Prompt failed ", err, i6)
		return
	}
	if i6 == 0 {
		serverListen.TLSCert = "cert.pem"
		serverListen.TLSKey = "cert.key"
		serverListen.Insecure = true
		clientDial.Insecure = true

		utils.PrintStr("你选择了默认自签名证书, 这是不安全的, 我们不推荐. 所以自动生成证书这一步需要你一会再到交互模式里选择相应选项进行生成。 \n")

	} else {
		utils.PrintStr("请输入 cert路径\n")

		promptCPath := promptui.Prompt{
			Label:    "path",
			Validate: utils.IsFilePath,
		}

		result, err = promptCPath.Run()
		if err != nil {
			fmt.Println("Prompt failed ", err, result)
			return
		}

		fmt.Printf("你输入了 %s\n", result)

		serverListen.TLSCert = result

		utils.PrintStr("请输入 key 路径\n")

		result, err = promptCPath.Run()
		if err != nil {
			fmt.Println("Prompt failed ", err, result)
			return
		}

		fmt.Printf("你输入了 %s\n", result)

		serverListen.TLSKey = result
	}

}
